Data Representation
========================================================
author: Alejandro Schuler, based on R for Data Science by Hadley Wickham
date: 2019
transition: none
width: 1680
height: 1050

```{r include=FALSE}
## better font size for slides
library(ggplot2)
theme_set(theme_grey(base_size = 22))
opts_chunk$set(collapse=TRUE,tidy=TRUE,prompt=TRUE,comment=NA,cache=FALSE)
opts_chunk$set(error=TRUE,warning=TRUE,message=TRUE)
```

Introduction to the course
========================================================
type: section


Goals of this course
========================================================
By the end of the course you should be able to...

- create and index vectors of different types
- efficiently manipulate strings, factors, and date-time vectors
- tightly control the intake of tabular data

<div align="center">
<img src="https://d33wubrfki0l68.cloudfront.net/571b056757d68e6df81a3e3853f54d3c76ad6efc/32d37/diagrams/data-science.png" width=800 height=300>
</div>

Resources for this course
========================================================

R for Data Science (R4DS): https://r4ds.had.co.nz
<div align="center">
<img src="https://r4ds.had.co.nz/cover.png">
</div>

***

- Vectors/lists: ch 20
- Strings, factors, date-times: ch 14, 15, 16
- Reading data: ch 11

Cheatsheets: https://www.rstudio.com/resources/cheatsheets/

Vectors and data types
========================================================
type: section

Tidyverse
========================================================
As usual, let's load the tidyverse before proceeding
```{r}
library(tidyverse)
```

Vector basics
========================================================
"As you dig deeper into R, you need to learn about vectors, the objects that underlie tibbles. If you’ve learned R in a more traditional way, you’re probably already familiar with vectors, as most R resources start with vectors and work their way up to tibbles. I think it’s better to start with tibbles because they’re immediately useful, and then work your way down to the underlying components" - Hadley Wickam

Vector basics
========================================================
- A vector in R is an ordered sequence of elements
- Each element has a particular **type**, e.g. string, numeric
- If all the elements in the vector are of the same type, then we call it an **atomic vector** or simply a **vector**
- If the elements are of different types, it is called a **list**, which will be discussed later

***

<div align="center">
<img src="https://d33wubrfki0l68.cloudfront.net/1d1b4e1cf0dc5f6e80f621b0225354b0addb9578/6ee1c/diagrams/data-structures-overview.png" height=600 width=700>
</div>

Why care about vectors? 
========================================================
- We can already manipulate data frames with tidyverse functions
```{r}
orange <- as_tibble(Orange)
orange %>%
  mutate(age_yrs = age/365) %>%
  mutate(approx_age_yr = round(age_yrs)) %>%
  group_by(approx_age_yr) %>%
  summarize(mean_circ = mean(circumference))
```

- However, each column in a dataframe is actually a **vector** and the functions we use inside `summarize()` and `mutate()` operate on these vectors. 
- So if  we want to write our own functions to use with data frames, we should understand a little bit about these basic objects

Vector basics
========================================================
- As we have already seen, vectors can be created with the `c()` function:
```{r}
shoesize <- c(9, 12, 6, 10, 10, 16, 8, 4) # integer vector
people <- c("Vinnie", "Patricia", "Gabriel") # character (string) vector
```
- Elements of a vector can be named
```{r}
c(x = 1, y = 2, z = 4)
```
- All vectors have two key properties: **length** and **type**, which you can check as follows:
```{r}
typeof(people)
typeof(shoesize)
length(people)
```

Vector basics
========================================================
- vectors of the same type can be combined with `c()`
```{r}
c(shoesize, c(4, 8, 10, 10))
```
- Regular numbers, strings, etc. are actually all treated as vectors of length 1
```{r}
12
```

Logical vectors
========================================================
```{r}
1:10 %% 3 == 0
c(TRUE, TRUE, FALSE, NA)
```
- logical vectors can only be one of three values: `TRUE`, `FALSE`, or `NA`.

Basic logical operations
========================================================
```{r}
TRUE & FALSE
TRUE | FALSE
!TRUE
```

- `&` is logical AND. It is true only if both arguments are true.
- `|` is logical OR. It is true if either argument is true.
- `!` is logical NOT.
- ADVANCED: see `?Logic` for more.

Numeric vectors
========================================================
```{r}
sqrt(1:10)
```
- Numeric vectors can be any number or one of three special values: `Inf` (1/0), `NaN` (0/0), and `NA` (missing)
- R uses scientific notation so `6.023e23` evaluates as `6.023 * 10^23` 

Floating point numbers
========================================================
  ```{r tidy=FALSE}
9.87
pi
```
- numeric vectors are typically doubles (sometimes integer)
- "double" means double-precision floating point.
- These are the computer representation of real numbers, that is,
numbers that necessarily have digits to the right of the decimal
point.
- integers take less space to store so they are preferable sometimes

- ADVANCED: R assumes the numbers you type are floating point, even if you
do not use a decimal point. R tries to avoid printing decimal points
when it can.

The perils of floating point
========================================================
```{r}
## is 4 equal to the square of the square root of 4?
4 == sqrt(4)^2
## is 2 equal to the square of the square root of 2?
2 == sqrt(2)^2
## is 1 equal to 1 plus some small number?
1 == 1 + 0.00000000000000000000001
```
- It is exceptionally difficult to get a computer to manipulate
approximations to real numbers correctly.
- This is very rarely a problem, but you can use `near()` from `dplyr` to stand in for `==` when you only need equality up to a certain precision
```{r}
# .Machine$double.eps is the smallest number R can represent
near(sqrt(2) ^ 2, 2, tol = .Machine$double.eps^0.5)
```

Other types
========================================================

We will discuss some of these other types in more detail later:

- strings
- factors (categories)
- date-times


NA represents missing values
========================================================
```{r}
1 + NA
sqrt(NA)
x <- c(1, 2, NA, 4)
1 + x
sqrt(x)
```
- It is quite common to have data sets where some of the values
are missing.
- Missing values are marked in R with `NA` (Not Available).
- `NA` can appear in any vector, list, or data frame. In
general, when `NA` is used in an element-wise vector
operation, the corresponding element of the result will be
`NA`.


Working with missing values
========================================================
```{r}
mean(c(1, 2, NA, 4))
mean(c(1, 2, NA, 4), na.rm = TRUE)
mean(c(1, 2, 4))
```
For R functions that aggregate results over an entire
vector, R can either:
  
  1. return `NA` if any of the relevant arguments are `NA`
  2. or leave out the `NA` values, and process the rest

Many functions let you control `NA` processing.
- In the second example, R leaves `NA` out of the numerator and denominator in
the calculation of the mean value.
- `rm` is short for "remove," so `na.rm` means "first remove the NA's
from the input, and then proceed."
- the syntax for doing this annoyingly often varies from function to function


How to test for NA
========================================================
```{r}
x <- c(1:5, NA)
x
x == NA                                 # this doesn't work!
is.na(x)
```
- You shouldn't use `==` to check if a value is `NA`. (Why not?)
- Use `is.na` instead.
- In R, `NULL` is a special value representing a empty or
absent object. It has its own type. It is often used as a placeholder for named arguments in function definitions
- So: `NULL` is not `NA`. `NULL` is an
empty/absent value. `NA` is a missing value.

Exercise: find the missing values
========================================================
```{r}
library(nycflights13) # install.packages(nycflights13)
```
Count the number of missing values in the `arr_delay` column of the `flights` data frame. Use pipes (`%>%`).
```{r}
head(flights)
```

Answer: find the missing values
========================================================
```{r}
flights %>%
  pull(arr_delay) %>%
  is.na() %>%
  sum()

flights %>%
  mutate(arr_delay_NA = is.na(arr_delay)) %>%
  summarize(arr_delay_NA_count = sum(arr_delay_NA))
```
What is the difference in output between these two?

Type coercion
========================================================
- some vector types can be easily converted to other types:
```{r}
as.character(shoesize)
```
- see `as.character()`, `as.logical()`, `as.numeric()`, etc.
- coercion most often happens implicitly when you use a vector in a context that is expecting a specific type:
```{r}
shoe_gt_8 = shoesize > 8
typeof(shoe_gt_8)
sum(shoe_gt_8) # under the hood, sum(as.numeric(shoe_gt_8))
mean(shoe_gt_8) # under the hood, mean(as.numeric(shoe_gt_8))
```

Type coercion
========================================================
- Implicit coercion also happens if you try and combine two vectors of different types
```{r}
(A <- c(TRUE, 1L))
typeof(A)
(B <- c(1L, 1.5))
typeof(B)
(C <- c(1.5, "a"))
typeof(C)
```

Testing type
========================================================
Use these to see if something is a vector or of the desired type. They all return either TRUE or FALSE
- is_logical() 
- is_integer()
- is_double()
- is_character()
- is_atomic() 
- is_list()
- is_vector()
```{r}
is_double(0.14) # neat
typeof(TRUE) == "logical" # not neat
```
- these functions are imported by `tidyverse`. Base R has its own equivalents but they are not well designed and sometimes produce surprising results. 

Matrices
========================================================
- A matrix is a 2D vector (with rows and columns)
```{r, echo=F}
my_example_matrix = matrix(rnorm(25), nrow=5)
```
```{r}
my_example_matrix
```

- All the usual vector rules apply- in particular, all entries of the matrix must be of the same type
```{r}
typeof(my_example_matrix)
```
- this distinguishes it from a data frame, which can have different types in different columns
- rows and columns can be named (the same way vector entries can be named)
- matrices are far more rare than vectors, but many modeling packages take numeric matrices as input, so it's good to be aware of them
- objects (including data frames) can be coerced to matrices using `as.matrix()`. 

Vectors, matrices, data frames
========================================================

<div align="center">
<img src="http://venus.ifca.unican.es/Rintro/_images/dataStructuresNew.png">
</div>

Exercise: coercing a data frame to matrix
========================================================
```{r}
# install.packages(nycflights13)
library(nycflights13)
(flights = as_tibble(flights))
```

Convert `flights` into a matrix and find out what type it is. Does this make sense?

Answer: coercing a data frame to matrix
========================================================
```{r}
matrix_flights = as.matrix(flights)
typeof(matrix_flights)
```

Subsetting a vector
========================================================
- We can get parts of a vector out by subsetting it. This is like `filter()`ing a data frame, but it looks a little different with vectors. We use `[ ]` with an index vector inside the brackets
```{r}
x <- c("first"=0.3, "second"=0.1, "third"=-5, "other"=12)
```
There are a few ways to subset a vector:
- with a numeric index vector of integers
```{r}
x[c(1,3)]
```
- with a logical index vector (of the same length)
```{r}
x[c(T,F,T,T)] # T is short for TRUE, F is short for FALSE
```
- with a character index vector (if the vector is named)
```{r}
x[c("first", "other")]
```

Indexing with integers
========================================================
```{r}
x
x[1] # same as x[c(1)] since 1 is already a vector (of length 1)
x[2:4]
x[c(3, 1)]
x[c(1,1,1,1,1,1,4)]
```
- Indexing returns a subsequence of the vector. It does not change
the original vector. Assign the result to a new variable to save it if you neeed it later.
- R starts counting vector indices from 1.
- You can index using a multi-element index vector.
- You can repeat index positions

Indexing with integers (negatives)
========================================================
```{r}
x
x[1]
x[-1]
x[-length(x)]
x[c(-1, -length(x))]
```
- You can't mix positive and negative vector indices in a single
index expression. R will complain.
- This is similar to the `df %>% select(-var)` syntax
- What about using `0` as an index? It is ignored.


Indexing with logicals
========================================================
```{r}
x
x >= 0
x[x >= 0]
```
- Logical values are either `TRUE` or `FALSE`.
- They are typically produced by using a comparison operator or
similar test.
- The logical index vector should be the same length as the vector being subsetted

Indexing 2D objects
========================================================
Similar syntax is used for 2D entities
```{r}
my_example_matrix[1:3, c(2,2)]
```
- the general pattern is `matrix[row_index, column_index]`.
- leaving either blank returns all rows or columns
```{r}
my_example_matrix[1:3,]
my_example_matrix[,c(T,T,F,F,T)]
```

Comparing tidyverse vs. vector indexing
====================================
```{r}
df <- tibble(x=x, y=rnorm(4), z=rnorm(4))
```
**Tidyverse**
```{r}
df %>% 
  filter(x>0) %>%
  select(x,y)
```
**Vector indexing**
```{r}
df[df$x>0, c(1,2)] # df$x takes the column x from the data frame df (details later)
```
- What are the advantages/disadvantages of each?

Tidyverse vs. vector indexing
====================================

- **Tidyverse**:
  - operations are ordered top-to-bottom/left-to-right in the way that they are being performed so the code can be read like natural language
  - each operation gets its own line, which facilitates finding bugs
  - functions are named sensibly so the code can be understood without knowledge of symbols like `$` or `[`. Even `$>$` is made to look like an arrow to suggest the left-to-right flow
  - variables are always referred to as bare names (no quotes or `$`)
  - will be easier for you to skim over and understand in 6 months
- **Vector indexing**
  - Fewer keystrokes
  - More familiar to programmers from C++ or python

***

**Tidyverse**
```{r, eval=F}
df %>% 
  filter(x>0) %>%
  select(x,y)
```
**Vector indexing**
```{r, eval=F}
df[df$x>0, c(1,2)] 
```

Working with strings
========================================================
type: section

String basics
========================================================
```{r}
c("1234", "sum(c(1,2,3,4))", "Alejandro", "a long string with weird characters!@#$!%>?", "NA", NA) 
```
- character vectors (or string vectors) store strings, which are arbitrary text (including spaces) or `NA` 
- even if the text can be interepreted by you as code or numbers, quoting it in `""` tells `R` that it is to be taken literally as text (note `"NA"` is a string, while `NA` is a special value that indicates a missing string if it is in a string vector)

stringr
========================================================
- Many of the functions we will use to work with strings come from the `stringr` package, which is `tidyverse`-associated, but not loaded with `library(tidyverse)`
```{r}
library(stringr)
```

String basics
========================================================
- Strings are created by quoting text with `" "` or `' '`. I always use `" "` to be consistent.
```{r}
string1 <- "This is a string"
```
- special characters (see `?"'"`) can be included by "escaping" them with `\`. `\\` is a literal backslash.
```{r}
string2_wrong = "This is a "string""
```
```{r}
string2_right = "This is a \"string\""
```
- check the length of a string with `str_length()` (why not `length()`?)
```{r}
x = "This is a string"
str_length(x)
length(x)
```

Combining strings
===
- Use `str_c()` to combine strings
```{r}
str_c("x", "y", "z")
```
- `sep` controls what gets stuck between them (`""` by default)
```{r}
str_c("x", "y", "z", sep = ", ")
```
- also works with vectors of strings
```{r}
str_c("prefix-", c("a", "b", "c"), "-suffix")
str_c(c("1", "2", "3"), c("a", "b", "c"), sep="-")
```
- and with a single vector, if you set the `collapse` argument
```{r}
name = "Alejandro"
x = c("Good afternoon,", name, "how are you?")
str_c(x, collapse=" ")
```

Subsetting 
===
- str_sub() does subsetting by start and end letters
- these can be negative numbers to count from the end of the string backwards
```{r}
str_sub("Hello world", start=1, end=5)
str_sub("Hello world", start=-5, end=-1)
```
- Also works on vectors
```{r}
x <- c("Apple", "Banana", "Pear")
str_sub(x, 1, 3)
```

Searching in strings
===
- `str_detect()` tells you if the query string is in the string (or vector of strings) you're looking at
```{r}
x <- c("apple", "banana", "pear")
str_detect(x, "e")
```

- `str_subset()` returns the strings in the vector that match the query
```{r}
str_subset(x, "e") # compare to x[str_detect(x,"e")]
```

Exercise: find rows according to string match
===
```{r, eval=F}
tibble(
  word = words, # words is an example string vector loaded by stringr
  i = seq_along(word) # seq_along(x) is the same as 1:length(x)
)
```
- Make this data fram for yourself
- Write code that returns all of rows with words that contain `"tr"`

Answer: find rows according to string match
===
```{r}
tibble(
  word = words, # words is an example string vector loaded by stringr
  i = seq_along(word) # seq_along(x) is the same as 1:length(x)
) %>%
  filter(str_detect(word, "tr"))
```

Counting the number of matches
===
- `str_count()` counts how many times the query appears in the string
```{r}
x <- c("apple", "banana", "pear")
str_count(x, "a")
```
- it pairs naturally with `mutate()`
```{r}
tibble(
    word = words, 
    i = seq_along(word) ) %>%
  mutate(count_e = str_count(word, "e")) %>%
  arrange(desc(count_e)) %>%
  head()
```

Replacing parts of a string
===
- sometimes you want to remove something from a string or replace it with something else.
- `str_replace_all()` lets you do this
```{r}
str_replace_all(x, "a", "-")
```
- use `""` as the replacement string to delete the part of the string that matches
```{r}
str_replace_all(x, "a", "-")
```
- you can also replace multiple strings at a time using a named vector
```{r}
x <- c("1 house", "2 cars", "3 people")
replacement_dictionary = c("1" = "one", "2" = "two", "3" = "three")
str_replace_all(x, replacement_dictionary)
```

Splitting up a string
===
- `str_split()` splits a string into multiple strings
```{r}
str_split("hello, how are you today?", " ")
```
- it returns a list, which is like a vector that can contain other vectors or arbitrary length as elements (more on this later). This allows it to operate on multiple strings at once without mashing the results together
```{r}
greeting = c("hello, how are you today?", 
             "I'm fine, thank you")
str_split(greeting, " ")
```
- we'll learn more about how to operate on lists in the functional programming course

Matching complicated patterns: regular expressions
===
- sometimes you want to match a pattern that is more complicated than a fixed string. For instance, how would you find all strings that have a vowel in them? Or match an email address?
- **regular expressions** (regexps) are a concise way of solving this problem, but they aren't pretty
- don't try and memorize all this, just get an idea of what's possible and then look at the cheat sheet later
- a regular expression is a string that is interpreted in a particular way as a query
- all of the `str_` functions we've talked about take regular expressions as queries. 
```{r}
x <- c("apple", "banana", "pear")
str_subset(x, "an")
```

- The `.` matches any character
```{r}
str_subset(x, ".a.")
```

Repetition
===
```{r}
babs = c("bb", "bab", "baab", "baaab")
```
- + after a character means match that character one or more times
```{r}
str_subset(babs, "ba+b")
```
- * after a character means match that character zero or more times
```{r}
str_subset(babs, "ba*b")
```
- ? after a character means match that character zero or one time
```{r}
str_subset(babs, "ba?b")
```
- {n,m} after a character means match between n and m repetitions
```{r}
str_subset(babs, "ba{2,3}b")
```

Anchors
=== 
- anchors tell the regexp to look at particular places in the string
- `^` matches the beginning
- `$` matches the end
```{r}
x <- c("apple", "banana", "pear")
str_subset(x, "^a")
str_subset(x, "a$")
```

Character classes
===
- Besides `.`, here are some other special sequences that match categories of characters
- `\\d`: matches any digit.
- `\\s`: matches any whitespace (e.g. space, tab, newline).
- `[abc]`: matches a, b, or c.
- `[a-zA-Z]`: matches any  letter
- `[^abc]`: matches anything except a, b, or c.
```{r}
str_subset(c("abc", "xyz"), "[aeiou]")
```

Exercise: what does this regex match?
===
`"^[a-zA-Z]+\\d+[a-zA-Z]+$"`

Answer: what does this regex match?
===
`"^[a-zA-Z]+\\d+[a-zA-Z]+$"` matches any string starting with a letter and ending a letter, but containing at least one number
```{r}
test_strs = c("c12341aaa", "123aa", "ba123", "asf  asdf", "G5s")
str_subset(test_strs, "^[a-zA-Z]+\\d+[a-zA-Z]+$")
```

Escaping special characters
===
- `\\` is used to escape special characters in regexps so that they can be interpreted literally
```{r}
str_extract(c("abc", "a.c", "bef"), "a\\.c")
```
- It takes two `\\` because a regex is a string. Thus the first `\` puts a literal `\` in the string, which is then interpreted as an escape character by the regex engine.

Extracting matches
===
- `str_extract()` will get the portion of the string that matches your regex
```{r}
emails = c("karina@stanford.edu", "nathalie@gmail.com", "carlos@kp.org")
str_extract(emails, "@.*")
```

Exercise: domain names
===
```{r}
emails = c("karina@stanford.edu", "nathalie@gmail.com", "carlos@kp.org")
```
Get the first part of the domain name out of these email addresses (for instance `kp` from `carlos@kp.org`)

Exercise: domain names
===
```{r}
emails = c("karina@stanford.edu", "nathalie@gmail.com", "carlos@kp.org")
```
Get the first domain names out of these email addresses (for instance `kp` from `carlos@kp.org`)
```{r}
emails %>%
  str_extract("@.*\\.") %>%
  str_sub(2,-2)
```

Look-arounds
===
- Sometimes you want to check if a string matches a pattern and then only return part of that pattern.
- For example, if you're looking for history of disease, you may want the disease, but not the term "history of"
```{r}
notes = c("... patient has history of MI ...",
          "... family history of diabetes ...",
          "... patient has nausea ... ")
str_extract(notes, "(?<=history of )[a-zA-Z]+(?= )")
```
- `(?=...)`: positive look-ahead assertion. Matches if ... matches at the current input.
- `(?!...)`: negative look-ahead assertion. Matches if ... does not match at the current input.
- `(?<=...)`: positive look-behind assertion. Matches if ... matches text preceding the current position, with the last character of the match being the character just before the current position. 
- `(?<!...)`: negative look-behind assertion. Matches if ... does not match text preceding the current position.

Regex is a broad topic
===
- There is a lot more to learn. This is a regex that matches valid email addresses:

```
(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
```
- But you can go very far with very little!
- Regex is not just in R, it is used across almost every programming language

stringr cheat sheet
===
<div align="center">
<img src="https://www.rstudio.com/wp-content/uploads/2018/08/strings.png", height=1000, width=1400>
</div>

Factors
===
type: section

Factor basics
===
- factors are R's representation of variables that can take values in a limited number of categoires
- the `tidyverse`-adjacent `forcats` (forcats = for-categoricals, also an anagram of factor!) package has useful functions for working with them
```{r}
library(forcats)
```
- consider a variable that stores a month of the year:
```{r}
months_vec <- c("Dec", "Apr", "Jan", "Mar")
```
- if you sort this vector, it sorts alphabetically, not by the order of the months
- you can accidentally add months that aren't legitimate: `c(months_vec, "Jam")`
- you can make a factor by hand with `factor()`
```{r}
month_levels <- c(
  "Jan", "Feb", "Mar", "Apr", "May", "Jun", 
  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
)
factor(months_vec, levels = month_levels)
```

Factor levels
===
```{r}
month_levels <- c(
  "Jan", "Feb", "Mar", "Apr", "May", "Jun", 
  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
)
factor(months_vec, levels = month_levels)
```
- the "levels" of the factor are the values that it is allowed to take as well as the order that it should be sorted in if desired
- `levels()` returns a character vector of the factor levels
- if the levels are not supplied, it takes the values in the vector as the levels in alphabetical order
```{r}
factor(months_vec)
```
- you can set the order of the levels to be by the order in which they appear in the vector using `fct_inorder()`
```{r}
factor(months_vec) %>%
  fct_inorder()
```

Example: gss_cat
===
- This is an example data frame loaded by `forcats` that has many factor columns, which are identifiable by the `<fct>` tag
- It’s a sample of data from the General Social Survey, which is a long-running US survey conducted by the independent research organization NORC at the University of Chicago.
```{r}
gss_cat
```

```{r}
gss_cat %>%
  pull(marital) %>%
  levels()
```

Ordering factor levels
===
- It’s often useful to change the order of the factor levels in a visualisation
- For example, imagine you want to explore the average number of hours spent watching TV per day across religions
```{r}
relig_tv = gss_cat %>%
  group_by(relig) %>%
  summarise(
    age = mean(age, na.rm = TRUE),
    tvhours = mean(tvhours, na.rm = TRUE),
    n = n())
ggplot(relig_tv, aes(tvhours, relig)) + 
  geom_point()
```

Ordering factor levels
===
- It would be better if the religions in this plot were ordered according to the number of TV hours
```{r}
relig_tv %>%
  mutate(relig = fct_reorder(relig, tvhours)) %>%
ggplot(aes(tvhours, relig)) + 
  geom_point()
```
- `fct_reorder()` takes in a factor vector and a numeric vector that is used to sort the levels

Ordering factor levels
===
- `fct_infreq()` orders by how often the levels appear in the factor vector
- `fct_rev()` reverses the order
```{r}
gss_cat %>%
  mutate(marital = marital %>% 
        fct_infreq() %>% 
        fct_rev()) %>%
ggplot(aes(marital)) +
  geom_bar()
```

Recoding factor levels
===
```{r}
gss_cat %>% 
  group_by(partyid) %>%
  summarize(count=n()) %>%
  arrange(desc(count))
```
- These factor levels are terrible
- we can change them with `fct_recode()`

Recoding factor levels
===
```{r}
gss_cat %>%
  mutate(partyid = fct_recode(partyid,
    "Republican, strong"    = "Strong republican",
    "Republican, weak"      = "Not str republican",
    "Independent, near rep" = "Ind,near rep",
    "Independent, near dem" = "Ind,near dem",
    "Democrat, weak"        = "Not str democrat",
    "Democrat, strong"      = "Strong democrat"
  )) %>%
  pull(partyid) %>%
  levels()
```
- Levels that you don't mention are left alone
- You can code multiple old levels to one new level (also see `?fct_collapse`)

Exercise: plotting factors over time
===
How have the proportions of people identifying as Democrat, Republican, and Independent changed over time? Make a plot to explore. `geom_bar()` may be useful. `scale_fill_manual()` may also be useful to associate parties with their familiar colors.

Answer: plotting factors over time
===
How have the proportions of people identifying as Democrat, Republican, and Independent changed over time? Make a plot to explore. `fct_collapse()` and `geom_bar()` may be useful. `scale_fill_manual()` may also be useful to associate parties with their familiar colors.
```{r}
plot_data = gss_cat %>%
  mutate(partyid = fct_collapse(partyid,
    Democrat = c("Not str democrat", "Strong democrat"),
    Republican = c("Not str republican", "Strong republican"),
    Independent = c("Independent", "Ind,near rep", "Ind,near dem"),
    Other = c("Other party", "Don't know", "No answer"))) %>%
  group_by(partyid, year) %>%
  summarize(count = n()) %>%
  mutate(proportion = count/sum(count)) 

party_colors = c(
  "Democrat" = "blue",
  "Republican" = "red",
  "Independent" = "purple",
  "Other" = "grey"
)
```

Answer: plotting factors over time
===
How have the proportions of people identifying as Democrat, Republican, and Independent changed over time? Make a plot to explore. `geom_bar()` may be useful. `scale_fill_manual()` may also be useful to associate parties with their familiar colors.
```{r}
plot_data %>%
ggplot(aes(x=year, y=proportion, fill=partyid)) + 
  geom_bar(position = "fill", stat = "identity") + 
  scale_fill_manual(values = party_colors)
```

Dates and times
=== 
type: section

Date and time objects in R
===
- Dates and times are not well captured as strings (since you can't do math with them) or as numbers (since date-time arithmetic is irregular), so they need their own data type
- we'll use the `tidyverse`-adjacent `lubridate` package to provide work with that data type
```{r}
library(lubridate) # install.package("lubridate")
```
- The data types that we will work with are `date` and `dttm` (date-time, also unhelpfully called POSIXct elsewhere in R).
```{r}
tibble(date_time = now(), # a date-time (dttm), prints as a string
       date = today()) # a date, also prints as a string
```
- Always use the simplest possible data type that works for your needs. Date-times are more complicated because of the need to handle time zones.

Creating dates from a string (or number)
===
- Dates:
```{r}
c(ymd("2017-01-31"), mdy("January 31st, 2017"),
  dmy("31-Jan-2017"), ymd(20170131))
```
- Date-times
```{r}
ymd_hms("2017-01-31 20:11:59")
mdy_hm("01/31/2017 08:01")
```
- All of these get printed out as strings, but they are actually `date` or dttm` objects
- these also all work on vectors, even if they fromatted heterogenously 
```{r}
x <- c(20090101, "2009-01-02", "2009 01 03", "2009-1-4",
       "2009-1, 5", "Created on 2009 1 6", "200901 !!! 07")
ymd(x)
```
- these functions are all pretty smart and detect most common delimitors (-, /, :, etc.), but you should check their input and output with sample data to make sure they are working correctly

Creating dates from components
===
- Sometimes the dates and times you get are split up (usually in columns)
```{r}
flights %>% 
  select(year, month, day, hour, minute)
```

Creating dates from components
===
- You can join them into dates or datetimes with `make_date()` or `make_datetime()`
```{r}
flights %>% 
  select(year, month, day, hour, minute) %>% 
  mutate(departure = make_datetime(year, month, day, hour, minute))
```

Creating dates from components
===
- lets do this for all of the times in the `flights` data frame
```{r}
flights %>% 
  head() %>% 
  pull(arr_time)
```
- note that `arr_time`, `sched_arr_time`, `dep_time`, and `sched_dep_time` are numeric and in an HHMM format! We have to fix that first (why is this bad?) 
```{r}
flights_fixed = flights %>%
  mutate(arr_time_hour = str_sub(arr_time, 1, -3) %>% as.numeric(),
         arr_time_min = str_sub(arr_time, -2, -1) %>% as.numeric(),
         sched_arr_time_hour = str_sub(sched_arr_time, 1, -3) %>% as.numeric(),
         sched_arr_time_min = str_sub(sched_arr_time, -2, -1) %>% as.numeric(),
         dep_time_hour = str_sub(dep_time, 1, -3) %>% as.numeric(),
         dep_time_min = str_sub(dep_time, -2, -1) %>% as.numeric(),
         sched_dep_time_hour = str_sub(sched_dep_time, 1, -3) %>% as.numeric(),
         sched_dep_time_min = str_sub(sched_dep_time, -2, -1) %>% as.numeric())
```
- Why does `str_sub()` work even though the thing being passed to it is numeric?
- This is a lot of typing and copy-paste. Later we will see how to write our own functions that make this less work and reduce the potential for typos

Creating dates from components
===
- Now we can aggregate all of these columns into nice `dttm`s
```{r}
flights_dt = flights_fixed %>% 
  # filter(!is.na(dep_time), !is.na(arr_time)) %>% 
  mutate(
    dep_time = make_datetime(year, month, day, 
                             dep_time_hour, dep_time_min),
    arr_time = make_datetime(year, month, day, 
                             arr_time_hour, arr_time_min),
    sched_dep_time = make_datetime(year, month, day, 
                                   sched_dep_time_hour, sched_dep_time_min),
    sched_arr_time = make_datetime(year, month, day, 
                                   sched_arr_time_hour, sched_dep_time_min)
  ) %>% 
  select(ends_with("time"), origin, dest, ends_with("delay"))
head(flights_dt)
```

Plotting with dates
===
- ggplot2 understands `ddtm`s
```{r}
flights_dt %>% 
  filter(ymd(20130101) < dep_time & dep_time < ymd(20130102)) %>% # get data from jan 1 2013
ggplot(aes(dep_time)) + # plot how many flights were leaving at each time of day
  geom_freqpoly(binwidth = 600) # 600 s = 10 minutes
```

Accessing dttm elements
===
- You can pull out individual parts of the date with the accessor functions `year()`, `month()`, `mday()` (day of the month), `yday()` (day of the year), `wday()` (day of the week), `hour()`, `minute()`, and `second()`

```{r}
flights_dt %>% 
  mutate(wday = wday(dep_time, label = TRUE)) %>% 
  ggplot(aes(x = wday)) +
    geom_bar()
```

Accessing dttm elements
===
- You can pull out individual parts of the date with the accessor functions `year()`, `month()`, `mday()` (day of the month), `yday()` (day of the year), `wday()` (day of the week), `hour()`, `minute()`, and `second()`

```{r}
flights_dt %>% 
  filter(!is.na(dep_time)) %>%
  mutate(minute = minute(dep_time)) %>% 
  group_by(minute) %>% 
  summarise(
    avg_delay = mean(arr_delay, na.rm = TRUE),
    n = n()) %>% 
ggplot(aes(minute, avg_delay)) +
  geom_line()
```

Date-time arithmetic
===
We will disucss `dttm` subtraction, addition, and division. These require the following data types:
- durations, which represent an exact number of seconds.
- periods, which represent human units like weeks and months.
- intervals, which represent a starting and ending point.

Durations
===
- Durations represent an exact span of time (i.e. in seconds)
```{r}
usa_age <- today() - ymd(17760704)
usa_age
```
- Subtracting `dttm`s in R gives something called a `difftime`, which ambiguously represents differences in weeks, days, hours, or seconds. A `duration` always uses seconds so it is preferable.
- You can conver to a duration with `as.duration()`
```{r}
as.duration(usa_age)
```
- `dseconds()`, `dminutes()`, `dhours()`, `ddays()`, `dweeks()`, and `dyears()` make durations of the given length of time and are vectorized
```{r}
ddays(194)
dweeks(1:4)
```

Duration arithmetic
===
- Durations can be added together and multiplied by numbers
```{r}
2 * (as.duration(usa_age) + dyears(1) + dweeks(12) + dhours(15))
```
- Or added and subtracted from `ddtm`s
```{r}
today() - as.duration(usa_age) # should give July 4 1776
```

- Weird things can happen with time zones
```{r}
one_pm <- ymd_hms("2016-03-12 13:00:00", tz = "America/New_York")
one_pm
one_pm + ddays(1) # not 1 PM anymore?!
```

Periods
===
- `Period`s are like `Duration`s but in "natural" human units
- `seconds()`, `minutes()`, `hours()`, `days()`, `weeks()`, `months()`, and `years()` make durations of the given length of time
```{r}
days(194)
weeks(5:9)
```
- Question: Why is there `months()` but no `dmonths()`?

Period arithmetic
===
- Periods can be added together and multiplied by numbers, just like Durations
```{r}
2 * (dyears(1) + dweeks(12) + dhours(15))
```
- Or added and subtracted from `ddtm`s
```{r}
today() - as.period(usa_age) # should give July 4 1776
```

- And they do more of what you would expect given daylight savings
```{r}
one_pm <- ymd_hms("2016-03-12 13:00:00", tz = "America/New_York")
one_pm
one_pm + days(1) # it knows that one "day" on this day is actually 23 hours, not 24
```

Example using periods
===
- some flights appear to arrive before they depart!
```{r}
flights_dt %>% 
  filter(arr_time < dep_time)  %>% 
  head()
```
- These are overnight
- We used the same date information for both the departure and the arrival times, but these flights arrived on the following day. 

Example using periods
===
- We can fix this by adding days(1) to the arrival time of each overnight flight.
```{r}
flights_dt <- flights_dt %>% 
  mutate(
    overnight = arr_time < dep_time,
    arr_time = arr_time + days(overnight), # will add 1 day if flight is overnight
    sched_arr_time = sched_arr_time + days(overnight)
  )
```

Intervals 
=== 
- An `interval` is a specific span of time with a start and end date(-time)
- They can be defined with the `%--%` operator, which you can read as "from... until" as in "from July 4 1776 until today"
```{r}
mdy("July 4 1776") %--% today()
```
- You can use %within% to see if a date or `dttm` falls in the interval
```{r}
flights_dt %>% 
  filter(dep_time %within% (mdy("feb 15 2013") %--% mdy("feb 25 2013"))) %>% 
  head()
```

Exercise: first days of the month
===
Create a vector of dates giving the first day of every month in 2015. Create a vector of dates giving the first day of every month in the current year.

Answer: first days of the month
===
Create a vector of dates giving the first day of every month in 2015. Create a vector of dates giving the first day of every month in the current year.

```{r}
ymd(20150101) + month(1:12)
make_date(year(today()), 1, 1) + month(1:12)
```

Fancy:
```{r}
today () %>%
  year() %>%
  make_date(1,1) + 
  month(1:12)
```

lubridate cheat sheet
===
<div align="center">
<img src="https://www.rstudio.com/wp-content/uploads/2018/08/lubridate.png", height=1000, width=1400>
</div>

Data import
===
type:section

Rationale
===
- Sometimes R fails to read in the data from a file
- Or you will read data into R and find strange errors when you try to manipulate it
- This is often caused by type mismatches- e.g. you expected a column to have been read in as a factor, but it was actually read in as a logical.
```{r}
file = readr_example("challenge.csv")
challenge = read_csv(file)
```

Diagnosing intake errors
===
- Use `readr::problems()` on the returned object to learn more about the errors
```{r}
problems(challenge)
```
- This tells us that `read_csv()` was expecting the `y` column to be logical, but when we look at what was actually in the file at rows 1001+, there are what appear to be dates!
- This happens because `read_csv()` does not know what type of data are in the file- you haven't told it, so it has to guess. 
- The way it guesses is by checking the first 1000 rows of each column and picking the most likely data type.
- You can tell `read_csv()` to check more rows before guessing by using the `guess_max` argument

Specifying data types
===
- In general, you may already know what types the columns should be, so you can provide those to `read_csv()`. 
```{r}
challenge = read_csv(file,
   col_types = cols(
     y = col_date()
   ))
head(challenge)
```
- This is a more robust solution than using more rows to guess
- Now we see that the problem was caused because the first 1000 rows of `y` are NAs
- Column types are provided to read_csv as named arguments to `cols()`, which itself is a named argument to `col_types`. 
- You do not need to specify all columns (here we let it guess what `x` is) but it is often good practice to do so if possible

Specifying data types
===
- Note that `col_date()` guessed the formatting of the dates (correctly in this case). 
- You can specify it using the `format` argument.
```{r}
challenge = read_csv(file,
   col_types = cols(
     y = col_date(format="%Y-%m-%d")
   ))
tail(challenge)
```
- You can also use a character string as a shortcut
```{r}
challenge = read_csv(file, col_types = "dD")
```
- Each character stands for the datatype of the corresponding column.
  - In this case, `d` in position 1 means the first column is a double, `D` in position two says the second column is a date.

Specifying data types
===
- Factors can also be read in with a high level of control
```{r}
df = readr_example("mtcars.csv")  %>%
read_csv(col_types = cols(
  cyl = col_factor(levels=c("4", "6", "8"))
))
```
- This will let you catch unexpected factor levels and set the proper order up-front! 
- To allow all levels, don't use the `levels` argument
```{r}
df = readr_example("mtcars.csv")  %>%
read_csv(col_types = cols(
  cyl = col_factor()
))
```

Non-csv flat files
===
- Besides .csv, you may find data in .tsv (tab-separated values) and other more exotic formats. 
- Many of these are still delimited text files ("flat files"), which means that the data are stored as text with special characters between new lines and columns. This is an exmaple .csv:
```{r}
toy_csv = "1,2,3\n4,5,6"
```
- This is an example .tsv
```{r}
toy_tsv = "1\t2\t3\n4\t5\t6"
```
- The only difference is the **delimiter** which is the character that breaks up columns. 

Non-csv flat files
===
- Both can be read in using `read_delim()`
```{r}
read_delim("1,2,3\n4,5,6", delim=",", col_names = c("x","y","z"))
read_delim("1\t2\t3\n4\t5\t6", delim="\t", col_names = c("x","y","z"))
```
- `read_csv()` is just a shortcut to `read_delim()` that has `delim=","` hardcoded in.

Non-flat files
===
- There are also other packages that let you read in from other formats
  - `haven` reads in SPSS, Stata, and SAS files
  - `readxl` reads in `.xls` and `.xlsx`
  - `DBI` with a database backend (e.g. `odbc`) reads in from databases
  - `jsonlite` and `xml2` for heirarchical data
  - `rio` for more esoteric formats
  
Writing files
===
```{r, eval=F}
write_csv(challenge, "/Users/c242587/Desktop/challenge.csv")
```
- metadata about column types is lost when writing to .csv
- use `write_rds()` (and `read_rds()`) to save to a binary R format that preserves column types
```{r, eval=F}
write_rds(challenge, "/Users/c242587/Desktop/challenge.rds")
```

Exercise: file I/O
===
What will happen if I run this code?
```{r, eval=F}
file = readr_example("challenge.csv")
challenge = read_csv(file,
   col_types = cols(
     y = col_date()
   ))
write_csv(challenge, "/Users/c242587/Desktop/challenge.csv")
challenge2 = read_csv("/Users/c242587/Desktop/challenge.csv")
```

Answer: file I/O
===
What will happen if I run this code?
```{r}
file = readr_example("challenge.csv")
challenge = read_csv(file,
   col_types = cols(
     y = col_date()
   ))
write_csv(challenge, "/Users/c242587/Desktop/challenge.csv")
challenge2 = read_csv("/Users/c242587/Desktop/challenge.csv")
```

readr cheat sheet
===
<div align="center">
<img src="https://www.rstudio.com/wp-content/uploads/2018/08/data-import.png", height=1000, width=1400>
</div>

Wrap-up
========================================================
type: section

Goals of this course
========================================================
By the end of the course you should be able to...

- create and index vectors of different types
- efficiently manipulate strings, factors, and date-time vectors
- tightly control the intake of tabular data

<div align="center">
<img src="https://d33wubrfki0l68.cloudfront.net/571b056757d68e6df81a3e3853f54d3c76ad6efc/32d37/diagrams/data-science.png" width=800 height=300>
</div>

Resources for this course
========================================================

R for Data Science (R4DS): https://r4ds.had.co.nz
<div align="center">
<img src="https://r4ds.had.co.nz/cover.png">
</div>

***

- Vectors/lists: ch 20
- Strings, factors, date-times: ch 14, 15, 16
- Reading data: ch 11
